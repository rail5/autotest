function get_random_free_port() {
	local RANDOM_PORT
	while : ; do
		RANDOM_PORT=@(expr @(expr $RANDOM % 16372) + 49152)
		netstat -ant | awk '{print $4}' | grep ":$RANDOM_PORT$" &>/dev/null || break
	done

	echo $RANDOM_PORT
}

# A single QEMU virtual machine on which we run tests
# We assume it's already set up & ready to boot on demand
# Another assumption: only one instance of each VM object is running at a time
@class VM {
	@public name="VM"
	@public imagePath
	@public ramSize=4096
	@public cpuCount=4
	@public username="root"
	@public password="password"

	@private qemuPID=0

	@private sshPort=0

	@public @method viewSSHPort {
		echo "@this.sshPort"
	}

	@private @method log message {
		# Message is either in $message/$1 or in stdin
		if [[ -n "$message" ]]; then
			# It's in the argument
			>&2 echo "[@{this.name}] $message"
			return
		fi

		# It's in stdin
		while IFS= read -r line; do
			>&2 echo "[@{this.name}] $line"
		done
	}

	@public @method boot stateless {
		if [[ ! -f "@this.imagePath" ]]; then
			@this.log "Error: Image file '@{this.imagePath}' not found!"
			return 1
		fi

		@this.log "Booting VM at @{this.imagePath}..."

		local statelessFlag="-snapshot"

		# Stateless mode is ENABLED unless EXPLICITLY set to "false"
		if [[ "$stateless" != "false" ]]; then
			@this.log "Stateless mode enabled: VM will not save any changes to the disk image."
		else
			@this.log "Persistent mode enabled: VM will save changes to the disk image."
			statelessFlag=""
		fi

		@this.sshPort=@(get_random_free_port)
		@this.log "Using SSH port @this.sshPort."

		qemu-system-x86_64 \
			-m @this.ramSize \
			-accel kvm \
			-smp @this.cpuCount \
			-net user,hostfwd=tcp::@{this.sshPort}-:22 \
			-net nic \
			-hda @this.imagePath \
			-nographic ${statelessFlag} &>/dev/null &
		
		@this.qemuPID=$!
		echo @this.qemuPID # Return the PID of the QEMU process for later use (e.g., shutdown)
	}

	@public @method signalWhenBooted timeout {
		local startTime=$(date +%s)
		while : ; do
			if [[ @this.sshPort -gt 0 ]]; then
				# Now wait until there's actually something running on that port
				until nc -z localhost @this.sshPort &>/dev/null; do
					if [[ -n "$timeout" ]]; then
						local currentTime=$(date +%s)
						if [[ $((currentTime - startTime)) -ge timeout ]]; then
							@this.log "Error: Timeout while waiting for SSH to become available on port @this.sshPort."
							return 1
						fi
					fi
					sleep 1
				done
				return 0 # VM is booted and SSH is available. Signal.
			fi

			if [[ -n "$timeout" ]]; then
				local currentTime=$(date +%s)
				if [[ $((currentTime - startTime)) -ge timeout ]]; then
					@this.log "Error: Timeout while waiting for VM to boot."
					return 1
				fi
			fi

			sleep 1
		done
	}

	@public @method sendFile localPath {
		if [[ ! -f "$localPath" ]]; then
			@this.log "Error: Local file '$localPath' not found!"
			return 1
		fi

		sshpass -p"@this.password" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -P @this.sshPort "$localPath" @this.username\@localhost:~/
		return $?
	}

	@public @method write {
		# Forward stdin to SSH
		# Using sshpass to provide the password non-interactively
		# I.e.,
		#    echo "command-name" | @VM.write
		# Should run "command-name" in the VM over SSH
		# Responses are then written out back via @this.log
		sshpass -p"@this.password" ssh -T \
			-o StrictHostKeyChecking=no \
			-o UserKnownHostsFile=/dev/null \
			-o LogLevel=ERROR \
			-p @this.sshPort @this.username\@localhost \
			"bash -s" <&0 2>&1 | @this.log
	}

	@public @method shutdown {
		# We cannot rely on commands such as "shutdown" being available inside the VM
		if [[ @this.qemuPID -le 0 ]]; then
			@this.log "VM not running; refusing to signal PID @this.qemuPID."
			return 0
		fi

		kill -SIGTERM @this.qemuPID 2>/dev/null || {
			@this.log "Error: Failed to send shutdown signal to VM process with PID @this.qemuPID."
			return 1
		}

		@this.qemuPID=0
	}
}
